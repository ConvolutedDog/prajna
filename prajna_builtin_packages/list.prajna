use __ptr::Ptr;

template <ValueType>
struct Node {
    next: Ptr<Node<ValueType>>;
    prev: Ptr<Node<ValueType>>;
    value: ValueType;
}

template <ValueType>
implement Node<ValueType> {
    /// @brief
    /// @warning 确保节点前面存在节点
    func InsertBefore(value: ValueType){
        var new_node = Ptr<Node<ValueType>>::New();
        new_node.value = value;
        var this_pointer = Ptr<Node<ValueType>>::FromThisRawPointer(&this);
        new_node.prev = this.prev;
        this.prev.next = new_node;
        new_node.next = this_pointer;
        this.prev = new_node;
    }

    /// @warning 确定节点后面存在节点
    func InsertAfter(value: ValueType){
        var new_node = Ptr<Node<ValueType>>::New();
        new_node.value = value;
        var this_pointer = Ptr<Node<ValueType>>::FromThisRawPointer(&this);
        new_node.next = this.next;
        this.next.prev = new_node;
        new_node.prev = this_pointer;
        this.next = new_node;
    }
}

template <ValueType>
struct List {
    _head: Ptr<Node<ValueType>>;
    _end: Ptr<Node<ValueType>>;
}

template <ValueType>
implement List<ValueType> {
    @static
    func Create()->List<ValueType> {
        var tmp_list : List<ValueType>;
        tmp_list._head = Ptr<Node<ValueType>>::New();
        tmp_list._end = Ptr<Node<ValueType>>::New();
        tmp_list._head.prev = Ptr<Node<ValueType>>::Null();
        tmp_list._head.next = tmp_list._end;
        tmp_list._end.prev =  tmp_list._head;
        tmp_list._end.next = Ptr<Node<ValueType>>::Null();
        return tmp_list;
    }

    func PushFront(value: ValueType) {
        this._head.InsertAfter(value);
    }

    func PushBack(value: ValueType) {
        this._end.InsertBefore(value);
    }

    func End()->Ptr<Node<ValueType>> {
        return this._end;
    }

    func Begin()->Ptr<Node<ValueType>> {
        return this._head.next;
    }
}
