template <Type_>
struct allocator<Type_>{}

template <Type_>
implement allocator<Type_>{
    @static
    func allocate(size: i64)->Type_ *{
        return cast<Type_ *>(malloc(size * sizeof(Type_)));
    }

    @static
    func deallocate(ptr: Type_*){
        free(cast<undef *>(ptr));
    }
}

template <Type_>
struct ptr<Type_>{
    raw_ptr: Type_*;
}

template <Type_>
implement ptr<Type_>{
    @static
    func allocate(size: i64)->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr = allocator<Type_>::allocate(size);
        bindings::registerReferenceCount(cast<undef*>(self.raw_ptr));
        bindings::incReferenceCount(cast<undef*>(self.raw_ptr));
        return self;
    }

    @static
    func new()->ptr<Type_>{
        var t = allocate(1);
        return t;
    }

    @static
    func null()->ptr<Type_>{
        var self: ptr<Type_>;
        return self;
    }

    func toi64()->i64{
        return this.raw_ptr.toi64();
    }

    // 因为内存计数是直接通过指针地址来记录的. 所以只要他们有相同的机制, 那么指针的传输, 转变不会导致错误.
    func toUndef()->ptr<undef>{
        var undef_ptr: ptr<undef>;
        undef_ptr.raw_ptr = cast<undef *>(this.raw_ptr);
        return undef_ptr;
    }

    @static
    func fromUndef(undef_ptr: ptr<undef>)->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr = cast<Type_ *>(undef_ptr.raw_ptr);
        return self;
    }

    @binary("==")
    func __equal__(rhs: ptr<Type_>)->bool{
        return this.raw_ptr.toi64() == rhs.raw_ptr.toi64();
    }

    @binary("!=")
    func __not_equal__(rhs: ptr<Type_>)->bool{
        return this.raw_ptr.toi64() != rhs.raw_ptr.toi64();
    }

    func isNull()->bool{
        return this.raw_ptr == __nullptr<Type_>::create();
    }

    func initialize(){
        this.raw_ptr = __nullptr<Type_>::create();
        bindings::registerReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func copy(){
        bindings::incReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func destroy(){
        bindings::decReferenceCount(cast<undef*>(this.raw_ptr));
        if (bindings::getReferenceCount(cast<undef*>(this.raw_ptr)) == 0){
            if (!this.isNull()){
                bindings::free(cast<undef*>(this.raw_ptr));
                //TODO 应该存在问题, 后期在进行详细修复
                this.raw_ptr = __nullptr<Type_>::create();
                "hit zzm\n".print();
            }
        }
    }

    func referenceCount()->i64 {
        return bindings::getReferenceCount(cast<undef*>(this.raw_ptr));
    }
}

export allocator;
export ptr;
