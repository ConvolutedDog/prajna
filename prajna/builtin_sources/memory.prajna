template <Type_>
struct allocator<Type_>{}

template <Type_>
implement allocator<Type_>{
    @static
    func allocate(size: i64)->Type_ *{
        return cast<Type_ *>(malloc(size * sizeof(Type_)));
    }

    @static
    func deallocate(ptr: Type_*){
        free(cast<undef *>(ptr));
    }
}

template <Type_>
struct ptr<Type_>{
    raw_ptr: Type_*;
}

template <Type_>
implement ptr<Type_> {
    @static
    func allocate(size: i64)->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr = allocator<Type_>::allocate(size);
        return self;
    }

    @static
    func new()->ptr<Type_>{
        return allocate(1);
    }

    func initialize(){
        this.raw_ptr = __nullptr<Type_>::create();
        bindings::registerReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func copy(){
        bindings::incReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func destroy(){
        bindings::decReferenceCount(cast<undef*>(this.raw_ptr));
        if (bindings::getReferenceCount(cast<undef*>(this.raw_ptr)) == 0){
            if (this.raw_ptr != __nullptr<Type_>::create()){
                bindings::free(cast<undef*>(this.raw_ptr));
                //TODO 应该存在问题, 后期在进行详细修复
                this.raw_ptr = __nullptr<Type_>::create();
            }
        }
    }

}

export allocator;
