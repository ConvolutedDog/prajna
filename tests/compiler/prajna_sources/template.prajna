template <T>
struct Node<T>{
    value: T;
    next: Node<T> *;
}

template <T>
implement Node<T>{
    func nextValue()->T{
        return (*this.next).value;
    }
}

template <T>
implement Node<T>{
    func nextValue2()->T{
        return this.nextValue();
    }
}



template ArrayTp <T, Rank>{
    implement T[Rank]{
        func length2()->i64{
            return Rank;
        }
    }
}

instantiate ArrayTp<i64, 3>;

template ptrTp <Type>{
    implement Type* {
        @instruction("CastInst", "PtrToInt", "i64")
        func toi64()->i64;
    }
}

instantiate ptrTp<i64>;

template <Type, Length>
struct MyArray<Type, Length>{
    data: Type[Length];
}

@test
func test(){
    var root: Node<f32>;
    root.value = 1.0;
    var next_node: Node<f32>;
    next_node.value = 2.0;
    root.next = &next_node;

    // var t: i64[3];
    // t.length2();
    // // testing::Assert(t.length2() == 3);

    // // var tt: i64*;
    // // print(tt.toi64().tostr());
    // root.nextValue();

    // var tmp: MyArray<i64, 2>;
    // // testing::Assert(root.nextValue() == 2.0);
}

